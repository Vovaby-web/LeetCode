package Lessons.LeetCode.Dinamic.C1_StyleFibonacci;
import java.util.*;
public class Solution {
  public static void main(String[] args) {
    // Задача №1
    // Вы поднимаетесь по лестнице из n ступенек. Чтобы достичь вершины, необходимо шагать вверх. Каждый раз
    // можно подниматься либо на 1, либо на 2 ступеньки.Сколькими различными способами вы можете подняться на вершину?
    System.out.println("Задача №1");
    System.out.println("Вариант №1 = " + task_1_v1(5));
    System.out.println("Вариант №1 = " + task_1_v2(5));
    System.out.println("Вариант №3 = " + task_1_v3(5));

    // Задача №2
    // Числа Фибоначчи, обычно обозначаемые, F(n) образуют последовательность, называемую последовательностью
    // Фибоначчи
    System.out.println("Задача №2");
    int n = 5;
    ArrayList<Integer> dp = new ArrayList<>(Collections.nCopies(n + 1, -1));
    System.out.println("Способ - 1 = " + task_2(n));
    System.out.println("Способ - 2 = " + task_2_v4(n));
    System.out.println("Способ - 3 = " + task_2_v2(n, dp));
    System.out.println("Способ - 4 = " + task_2_v3(n));

    // Задача №3
    // Вы поднимаетесь по лестнице из n ступенек. Чтобы достичь вершины, необходимо шагать вверх. Каждый раз можно
    // подниматься либо на 1, либо на 2, либо на m ступенек. Сколькими различными способами вы можете
    // подняться на вершину?
    System.out.println("Задача №3");
    n = 4;        // Количество ступеняк на которые можем подняться
    int m = 2;    // Максимальное количество шагов, которые можно сделать
    System.out.println(rec(n, m));

    // Задача №4
    // Найти последовательность Трибоначчи
    System.out.println("Задача №4");
    System.out.println(trib(5));

    // Задача №5
    // Вам дан целочисленный массив, cost где cost[i] — стоимость шага по лестнице. Заплатив стоимость, вы сможете
    // подняться на одну или две ступеньки. i^th. Вы можете начать с шага с индексом 0 или с шага с индексом 1.
    // Найти минимальную стоимость достижения вершины этажа.
    System.out.println("Задача №5");
    int a[] = {1, 100, 1, 1, 1, 100, 1, 1, 100, 1};
    System.out.println("Способ 1 = " + task_5_v1_climb(a));
    System.out.println("Способ 2 = " + task_5_v1(a));
    System.out.println("Способ 3 = " + task_5_v2_climb(a));

    // Задача №6
    // Вы профессиональный грабитель, планирующий грабить дома на улице. В каждом доме спрятана определенная сумма
    // денег, единственное ограничение, которое мешает вам ограбить каждый из них, это то, что в соседних домах
    // подключены системы безопасности, и они автоматически свяжутся с полицией, если в одну ночь были взломаны
    // два соседних дома.
    System.out.println("Задача №6");
    int[] a6 = {2, 1, 1, 2};
    System.out.println("Вариант 1 = " + task_6_v1(a6));
    System.out.println("Вариант 2 = " + task_6_v2(a6, 0, a.length - 1));
    int[] dp6 = new int[a6.length + 1];
    Arrays.fill(dp6, -1);
    System.out.println("Вариант 3 = " + task_6_v3(a6, 0, a6.length - 1, dp6));
    System.out.println("Вариант 4 = " + task_6_v4(a6, a6.length));
    System.out.println("Вариант 5 = " + task_5_v5(a6));

    // Задача №7
    // Вам дан целочисленный массив nums.
    // Вы хотите максимизировать количество получаемых очков, выполняя следующую операцию любое количество раз:
    // Выберите любой nums[i] и удалите его, чтобы заработать nums[i] очки. После этого вы должны удалить
    // каждый элемент, равный nums[i] - 1 и каждый элемент, равный nums[i] + 1.
    // Верните максимальное количество очков, которое вы можете заработать, применив описанную
    // выше операцию несколько раз.
    System.out.println("Задача №7");
    int a7[] = {2, 2, 3, 3, 3, 4};
    System.out.println(task_7_v2(a7));
  }
  /* Задача №1
  Вы поднимаетесь по лестнице из n ступенек. Чтобы достичь вершины, необходимо шагать вверх. Каждый раз можно
  подниматься либо на 1, либо на 2 ступеньки. Сколькими различными способами вы можете подняться на вершину?
   Пример 1:
    Входные данные: n = 2
    Выходные данные: 2
    Объяснение: Есть два способа подняться на вершину.
    1. 1 шаг + 1 шаг
    2. 2 шага
   Пример 2:
    Входные данные: n = 3
    Выходные данные: 3
    Объяснение: Есть три способа подняться на вершину.
    1. 1 шаг + 1 шаг + 1 шаг
    2. 1 шаг + 2 шага
    3. 2 шага + 1 шаг
    Пример 3:
    Входные данные: n = 5
    Выходные данные: 8
    Объяснение: Есть восемь способов подняться на вершину.
    1. 1 шаг + 1 шаг + 1 шаг + 1 шаг + 1 шаг
    2. 1 шаг + 1 шаг + 1 шаг + 2 шага
    3. 1 шаг + 1 шаг + 2 шага + 1 шаг
    4. 1 шаг + 2 шага + 1 шаг + 1 шаг
    5. 2 шага + 1 шаг + 1 шаг + 1 шаг
    6. 1 шаг + 2 шага + 2 шага
    7. 2 шага + 1 шаг + 2 шага
    8. 2 шага + 2 шага + 1 шаг
  */
  // Задача №1
  // Самый простой способ
  // climbStairs_v1(n - 1) - все возможные шаги на 1 ступеньку
  // climbStairs_v1(n - 2) - все возможные шаги на 2 ступеньки
  static int task_1_v1(int n) {
    if (n == 0 || n == 1)
      return 1;
    return task_1_v1(n - 1) + task_1_v1(n - 2);
  }
  // Задача №1
  public static int task_1_v2(int n) {
    int[] dp = new int[n + 1];        // Создаем массив
    Arrays.fill(dp, -1);         // Заполняем его -1
    return task_1_solve(0, n, dp);
  }
  /* Задача №1
   Метод solve — это рекурсивная вспомогательная функция для расчета количества различных способов подняться
   по лестнице. Он использует мемоизацию, сохраняя промежуточные результаты в dp массиве, чтобы избежать избыточных
   вычислений.
   Базовые случаи: если n меньше 0, результат равен 0.
   Если n=0, есть один способ подняться (ничего не делая).
   Функция рекурсивно вычисляет количество способов, суммируя результаты подъема
   (n-1) по лестнице и (n-2).
  */
  private static int task_1_solve(int i, int n, int[] dp) {
    if (i == n) return 1;
    if (i > n) return 0;
    if (dp[i] != -1) return dp[i];
    int dp1 = task_1_solve(i + 1, n, dp);
    System.out.print(i + "= " + dp1 + " + ");
    int dp2 = task_1_solve(i + 2, n, dp);
    System.out.println(dp2);
    dp[i] = dp1 + dp2;
    return dp[i];
  }
  /* Задача №1
   Инициализация: Инициализируйте три переменные a, b, и cзначениями 0, 1 и 0 соответственно. Эти переменные
   представляют количество способов подняться по лестнице на текущем, предыдущем и двух шагах назад соответственно.
   Итеративный расчет: используйте цикл для повторения n раз.
   В каждой итерации:
    Обновление c должно быть суммой a и b.
    Обновить a предыдущее значение b.
    Обновите b текущее значение c.
   Конечный результат: после цикла значение b представляет количество способов
   подняться по лестнице по n ступеням.
   Возвращаемый результат: возвращает окончательное значение b как результат climbStairs.
  */
  public static int task_1_v3(int n) {
    int a = 0; // Предыдущая ступенька
    int b = 1; // Текущая ступенька
    int c;     // Два шага назад
    for (int i = 0; i < n; i++) {
      c = a + b;
      a = b;
      b = c;
    }
    return b;
  }
  /* Задача №2
  Числа Фибоначчи , обычно обозначаемые, F(n) образуют последовательность, называемую последовательностью Фибоначчи,
  так что каждое число представляет собой сумму двух предыдущих, начиная с 0 и 1. То есть,
   Числовая пара Фиббоначи
   0  1  2  3  4  5  6  7   9
   0, 1, 1, 2, 3, 5, 8, 13, 21 ...
   F(0) = 0, F(1) = 1
   F(n) = F(n - 1) + F(n - 2), для n > 1.
   Учитывая n, посчитайте F(n).
   Пример 1:
   Входные данные: n = 2
   Выходные данные: 1
   Объяснение: F(2) = F(1) + F(0) = 1 + 0 = 1.
   Пример 2:
   Входные данные: n = 3
   Выходные данные: 2
   Объяснение: F(3) = F(2) + F(1) = 1 + 1 = 2.
   Пример 3:
   Вход: n = 4
   Выход: 3
   Объяснение: F(4) = F(3) + F(2) = 2 + 1 = 3.
  */
  // TC -- O(2^N) and SC -- O(N)
  static int count = 0;
  static int task_2(int n) {
    count++;
    // 1. Base Case
    if (n == 1 || n == 2)
      return 1;
    return task_2(n - 1) + task_2(n - 2);
  }
  // Задача №2
  // Using topDown Approach --> Recursion + Memoization
  // TC -- O(N + N) and SC -- O(N)
  static int task_2_v2(int n, ArrayList<Integer> dp) {
    // 1. Base Case (базовое ограничение)
    if (n == 1 || n == 0)
      return n;
    // 2. Check if ans already exists
    if (dp.get(n) != -1)
      return dp.get(n);
    // 3. Store ans in dp array
    dp.set(n, task_2_v2(n - 1, dp) + task_2_v2(n - 2, dp));
    // 4. Return dp array
    return dp.get(n);
  }
  // Задача №2
  // Using bottomUp Approach --> Tabulation Method [Iterative Way]
  // TC -- O(N) and SC -- O(N)
  static int task_2_v3(int n) {
    // 1. Create dp array
    ArrayList<Integer> dp = new ArrayList<>(Collections.nCopies(n + 1, -1));
    // 2. Base Case
    dp.set(0, 0);
    if (n == 0) return dp.get(0);
    dp.set(1, 1);
    if (n == 1) return dp.get(1);
    // 3.
    for (int i = 2; i <= n; i++) {
      dp.set(i, dp.get(i - 1) + dp.get(i - 2));
    }
    return dp.get(n);
  }
  // Задача №2
  // Space Optimization
  // TC -- O(N) and SC -- O(1)
  static int task_2_v4(int n) {
    int prev2 = 0;
    int prev1 = 1;
    int curr = 0;
    if (n <= 1) return n;
    for (int i = 2; i <= n; i++) {
      curr = prev1 + prev2;
      // Shifting
      prev2 = prev1;
      prev1 = curr;
    }
    return curr;
  }
  /* Задача №3
  Вы поднимаетесь по лестнице из n ступенек. Чтобы достичь вершины, необходимо шагать вверх. Каждый раз можно
  подниматься либо на 1, либо на 2, либо на m ступенек. Сколькими различными способами вы можете подняться на вершину?
  Пример 1:
  Входные данные: n = 2 m = 2
  Выходные данные: 2
  Объяснение: Есть два способа подняться на вершину.
  1. 1 шаг + 1 шаг
  2. 2 шага
  Пример 2:
  Входные данные: n = 3 m = 2
  Выходные данные: 3
  Объяснение: Есть три способа подняться на вершину.
  1. 1 шаг + 1 шаг + 1 шаг
  2. 1 шаг + 2 шага
  3. 2 шага + 1 шаг
  Пример 3:
  Входные данные: n = 4 m = 3
  Выходные данные: 7
  Объяснение: Есть семь способов подняться на вершину.
  1. 1 шаг + 1 шаг + 1 шаг + 1 шаг
  2. 1 шаг + 1 шаг + 2 шага
  3. 1 шаг + 2 шага + 1 шаг
  4. 2 шага + 1 шаг + 1 шаг
  5. 2 шага + 2 шага
  6. 3 шага + 1 шаг
  7. 1 шаг + 3 шага
  */
  public static int rec(int n, int m) {
    if (n == 0 || n == 1)           // Если 0 или 1 этаж, то считаем за 1
      return 1;
    if (n < 0)                      // Все, что ниже где мы стоим не считается
      return 0;
    int res = 0;
    // Через сколько мы ступенек шагаем, столько раз должны запускать метод rec
    for (int i = 1; i <= m; i++)
      res += rec(n - i, m);     // rec(n - 1, m)+rec(n - 2, m)+...+rec(n - m, m)
    return res;
  }
  /* Задача №4
  Последовательность Трибоначчи T n определяется следующим образом:
  T(0) = 0, T(1) = 1, T(2) = 1
  T(n+3) = T(n) + T(n+1) + T(n+2) для n >= 0.
  Учитывается, что n вернет значение T(n).
  Пример 1:
   Вход: n = 4
   Выход: 4
  Объяснение:
    Т(3) = 0 + 1 + 1 = 2
    Т(4) = 1 + 1 + 2 = 4
  Пример 2:
   Вход: n = 5
   Выход: 7
   Объяснение:
    Т(3) = 0 + 1 + 1 = 2
    Т(4) = 1 + 1 + 2 = 4
    Т(5) = 1 + 2 + 4 = 7
  Пример 3:
   Ввод: n = 25
   Вывод: 1389537
  */
  static int trib(int n) {
    if (n == 0 || n == 1)
      return n;
    if (n == 2) return 1;
    return trib(n - 1) + trib(n - 2) + trib(n - 3);
  }
  /* Задача №5
  Вам дан целочисленный массив, cost где cost[i] — стоимость шага по лестнице. Заплатив стоимость, вы сможете
  подняться на одну или две ступеньки. i^th. Вы можете начать с шага с индексом 0 или с шага с индексом 1.
  Найти минимальную стоимость достижения вершины этажа.
  Пример 1:
  Входные данные: стоимость = [10, 15, 20]
  Выходные данные: 15
  Объяснение:
   Вы начнете с индекса 1.
   Заплатите 15 и поднимитесь на две ступеньки, чтобы достичь вершины.
   Общая стоимость 15.
  Пример 2:
  Ввод: стоимость = [ 1 ,100, 1 ,1, 1 , 100, 1 , 1 ,100, 1 ]
  Выход: 6
  Объяснение: Вы начнете с индекса 0.
  - Заплатите 1 и поднимитесь на две ступеньки, чтобы достичь индекса 2.
  - Заплатите 1 и поднимитесь на две ступеньки, чтобы достичь индекса 4.
  - Заплатите 1 и поднимитесь на две ступеньки, чтобы достичь индекса 6.
  - Заплатите 1 и поднимитесь на одну ступень, чтобы достичь индекса 7.
  - Заплатите 1 и поднимитесь на две ступеньки, чтобы достичь индекса 9.
  - Заплатите 1 и поднимитесь на одну ступеньку, чтобы достичь вершины.
  Общая стоимость 6.
  Решение
  Мы начинаем либо с шага 0, либо с шага 1.
  Цель состоит в том, чтобы достичь либо последнего, либо предпоследнего шага,
  в зависимости от того, какой из них является минимальным.
  Шаг 1. Определите рекурсивное отношение между подзадачами.
  В этой задаче рекуррентное соотношение:
  mincost(i) = cost[i]+min(mincost(i-1), mincost(i-2))
  базовые случаи:  mincost(0) = cost[0], mincost(1) = cost[1]
  */
  public static int task_5_v1(int[] cost) {
    int n = cost.length;
    //  1. Базовые случаи: если количество ступенек меньше или равно 2 (т. е. n <= 2),
    //  возвращается минимальная стоимость первых двух ступеней. Это связано с тем, что
    //  для первых двух лестниц вы можете выбрать любую из них, чтобы минимизировать затраты.
    if (n <= 2)
      return Math.min(cost[0], cost[1]);
    // Инициализация: инициализируйте две переменные firstи second, чтобы представить
    // минимальную стоимость достижения первой и второй лестницы.
    // Устанавливается first стоимость первой ступени и second стоимость второй ступени.
    int first = cost[0];
    int second = cost[1];
    // Цикл динамического программирования: переберите оставшиеся ступени (от третьей до последней)
    // с помощью цикла:
    // а. Рассчитайте currentCost стоимость текущей лестницы, сложив стоимость текущей лестницы
    // и минимум firstи second. Это представляет собой минимальную стоимость достижения текущей
    // лестницы.
    // Обновите firstи second переместите их вперед, где first станет предыдущим значением
    // secondи secondстанет currentCost. Это подготавливает их к следующей итерации.
    for (int i = 2; i < n; i++) {
      int currentCost = cost[i] + Math.min(first, second);
      first = second;
      second = currentCost;
    }
    // Возвращаемый минимум: после цикла верните минимум firstи second.
    // Это представляет собой минимальную стоимость достижения вершины лестницы.
    return Math.min(first, second);
  }
  // Задача №5
  // Recursive Top Down - O(2^n) Time Limit Exceeded
  public static int task_5_v1_climb(int[] cost) {
    int n = cost.length;
    return Math.min(task_5_v1(cost, n - 1), task_5_v1(cost, n - 2));
  }
  private static int task_5_v1(int[] cost, int n) {
    if (n < 0) return 0;
    if (n == 0 || n == 1) return cost[n];
    return cost[n] + Math.min(task_5_v1(cost, n - 1), task_5_v1(cost, n - 2));
  }
  // Задача №5
  // Top Down Memoization - O(n) 1ms
  static int[] dp;
  public static int task_5_v2_climb(int[] cost) {
    int n = cost.length;
    dp = new int[n];
    return Math.min(task_5_v2(cost, n - 1), task_5_v2(cost, n - 2));
  }
  // Задача №5
  private static int task_5_v2(int[] cost, int n) {
    if (n < 0) return 0;
    if (n == 0 || n == 1) return cost[n];
    if (dp[n] != 0) return dp[n];
    dp[n] = cost[n] + Math.min(task_5_v2(cost, n - 1), task_5_v2(cost, n - 2));
    return dp[n];
  }
  /* Задача №6
  Вы профессиональный грабитель, планирующий грабить дома на улице. В каждом доме спрятана определенная сумма денег,
  единственное ограничение, которое мешает вам ограбить каждый из них, это то, что в соседних домах подключены системы
  безопасности, и они автоматически свяжутся с полицией, если в одну ночь были взломаны два соседних дома.
  Дан целочисленный массив nums, представляющий сумму денег в каждом доме. Найдите максимальную сумму денег, которую
  вы можете ограбить сегодня вечером, не предупредив полицию.
  Пример 1:
  Ввод: nums = [1,2,3,1]
  Выход: 4
  Объяснение:
  Ограбить дом 1 (деньги = 1), а затем ограбить дом 3 (деньги = 3).
  Общая сумма, которую вы можете ограбить = 1 + 3 = 4.
  Пример 2:
  Ввод: nums = [2,7,9,3,1]
  Выход: 12
  Объяснение:
  Ограбить дом 1 (деньги = 2), ограбить дом 3 (деньги = 9) и ограбить дом 5 (деньги = 1).
  Общая сумма, которую вы можете ограбить = 2 + 9 + 1 = 12.
  */
  static int task_6_v1(int[] nums) {
    int n = nums.length;
    if (n == 0) return 0;
    else if (n == 1) return nums[0];
    else if (n == 2) return Math.max(nums[0], nums[1]);
    List<Integer> dp =
        new ArrayList<>(Collections.nCopies(n, 0));
    dp.set(0, nums[0]);
    dp.set(1, Math.max(nums[0], nums[1]));
    for (int i = 2; i < n; i++) {
      dp.set(i, Math.max(dp.get(i - 1), nums[i] + dp.get(i - 2)));
    }
    return dp.get(n - 1);
  }
  // Задача №6
  // solve принимает nums массив и два индекса s и e представляет начало и конец текущего подмассива.
  // Он рекурсивно вычисляет максимальную сумму, которую можно ограбить, либо ограбив текущий дом (nums[s])
  // и пропустив следующий, либо пропустив текущий дом и перейдя к следующему.
  public static int task_6_v2(int[] nums, int s, int e) {
    // Базовые случаи проверяют, больше ли начальный индекс, чем конечный индекс,
    // или равны ли начальный и конечный индексы (остался только один дом).
    if (s > e) return 0;
    if (s == e) return nums[s];
    return Math.max(nums[s] + task_6_v2(nums, s + 2, e),
        task_6_v2(nums, s + 1, e));
  }
  // Задача №6
  // Этот подход аналогичен рекурсивному, но включает в себя запоминание,
  // чтобы избежать избыточных вычислений.
  // Массив dp используется для хранения результатов подзадач во избежание их пересчета.
  public static int task_6_v3(int[] nums, int s, int e, int[] dp) {
    if (s > e)
      return 0;
    if (s == e)
      return nums[s];
    if (dp[s] != -1)
      return dp[s];
    return dp[s] = Math.max(nums[s] + task_6_v3(nums, s + 2, e, dp),
        task_6_v3(nums, s + 1, e, dp));
  }
  // Задача №6
  // метод solveTAB использует итеративный восходящий подход для заполнения массива dp. Он выполняет итерацию по
  // массиву в обратном направлении nums, вычисляя максимальную сумму, которую можно ограбить в каждом доме,
  // и сохраняет результаты в dp массиве. Затем извлекается окончательный результат dp[0], который представляет собой
  // максимальную сумму, которую можно ограбить, начиная с первого дома.
  public static int task_6_v4(int[] nums, int n) {
    int[] dp = new int[n + 2];
    for (int i = n - 1; i >= 0; i--) {
      dp[i] = Math.max(nums[i] + dp[i + 2], dp[i + 1]);
    }
    return dp[0];
  }
  // Задача №6
  // Временная сложность: O(N), где N — количество домов.
  // Пространственная сложность: O(1), поскольку мы используем постоянное
  // пространство для переменных rob и norob.
  public static int task_5_v5(int[] nums) {
    // Используйте две переменные rob и norob, чтобы отслеживать максимальную сумму денег,
    // украденную с ограблением текущего дома или без него.
    int rob = 0;
    int norob = 0;
    for (int i = 0; i < nums.length; i++) {
      // Перебираем каждый дом и на каждом шаге вычисляем максимальную сумму денег,
      // если текущий дом ограблен (newRob) и не ограблен (newNoRob).
      int newRob = norob + nums[i];
      int newNoRob = Math.max(norob, rob);
      // Обновите rob и norob для следующей итерации.
      rob = newRob;
      norob = newNoRob;
    }
    // Конечный результат — это максимальная сумма между двумя сценариями:
    // ограбить последний дом или не ограбить его.
    return Math.max(rob, norob);
  }
  /* Задача №7
  Вам дан целочисленный массив nums.
  Вы хотите максимизировать количество получаемых очков, выполняя следующую операцию любое количество раз:
  Выберите любой nums[i] и удалите его, чтобы заработать nums[i] очки. После этого вы должны удалить
  каждый элемент, равный nums[i] - 1 и каждый элемент, равный nums[i] + 1.
  Верните максимальное количество очков, которое вы можете заработать, применив описанную
  выше операцию несколько раз.
  Пример 1:
   Ввод: nums = [3,4,2]
   Вывод: 6
   Объяснение: Вы можете выполнять следующие операции:
    - Удалите 4, чтобы заработать 4 очка. Следовательно, 3 также удаляется. числа = [2].
    - Удалите 2, чтобы заработать 2 очка. числа = [].
   Всего вы заработаете 6 баллов.
  Пример 2:
    Ввод: nums = [2,2,3,3,3,4]
    Вывод: 9
    Объяснение: Вы можете выполнять следующие операции:
     - Удалите 3, чтобы заработать 3 очка. Все 2 и 4 также удаляются. числа = [3,3].
     - Удалите 3 еще раз, чтобы заработать 3 очка. числа = [3].
     - Удалите 3 еще раз, чтобы заработать 3 очка. числа = [].
   Всего вы заработаете 9 баллов.
  */
  public static int task_7(int[] nums) {
    Arrays.sort(nums);
    HashMap<Integer, Integer> hm = new HashMap<>();
    for (int i : nums) {
      hm.put(i, hm.getOrDefault(i, 0) + 1);
    }
    Integer dp[][] = new Integer[nums.length + 1][100];
    return task_7_Help(nums, hm, 0, dp, 0);
  }
  public static int task_7_Help(int nums[], HashMap<Integer, Integer> hm, int i, Integer dp[][], int prev) {
    if (i >= nums.length) {
      return 0;
    }
    if (dp[i][prev] != null) {
      return dp[i][prev];
    }
    boolean f1 = false;
    int pick = 0;
    int n_pick = 0;
    int freq = 0;
    if (hm.get(nums[i]) > 0) {
      hm.put(nums[i], hm.get(nums[i]) - 1);
      if (hm.containsKey(nums[i] + 1)) {
        freq = hm.get(nums[i] + 1);
        hm.put(nums[i] + 1, 0);
        f1 = true;
      }
      pick = nums[i] + task_7_Help(nums, hm, i + 1, dp, nums[i] % 100);
      hm.put(nums[i], hm.get(nums[i]) + 1);
      if (f1) hm.put(nums[i] + 1, freq);
      n_pick = Math.max(n_pick, task_7_Help(nums, hm, i + 1, dp, prev));
    } else
      n_pick = Math.max(n_pick, task_7_Help(nums, hm, i + 1, dp, prev));
    return dp[i][prev] = Math.max(pick, n_pick);
  }
  public static int task_7_v2(int[] nums) {
    Arrays.sort(nums);
    List<int[]> list = new ArrayList<>();
    for (int num : nums) {
      if (!list.isEmpty() && list.get(list.size() - 1)[0] == num) {
        list.get(list.size() - 1)[1]++;
      } else {
        list.add(new int[]{num, 1});
      }
    }
    int n = list.size();
    int ans = task_7_dp(list, 0, new int[n], n);
    return ans;
  }
  private static int task_7_dp(List<int[]> list, int idx, int[] memo, int n) {
    if (idx >= n)
      return 0;
    if (memo[idx] != 0)
      return memo[idx];
    int curr = list.get(idx)[0] * list.get(idx)[1];
    int nextToAdj = task_7_dp(list, idx + 2, memo, n) + curr;
    int adj = task_7_dp(list, idx + 1, memo, n);
    if (idx < n - 1 && list.get(idx + 1)[0] != list.get(idx)[0] + 1) {
      adj += curr;
    }
    memo[idx] = Math.max(adj, nextToAdj);
    return memo[idx];
  }


}
