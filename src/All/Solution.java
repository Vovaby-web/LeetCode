package Lessons.LeetCode.All;
import java.util.Arrays;
public class Solution {
  public static void main(String[] args) {
    // 268
    // Учитывая массив nums, содержащий n различные числа в диапазоне [0, n], верните единственное число в диапазоне,
    // которое отсутствует в массиве.
    System.out.println("Задача №268:");
    int[] a268 = {9, 6, 4, 2, 3, 5, 7, 0, 1};
    System.out.println(task_268(a268));

    // 443. Сжатие строк
    System.out.println("Задача №443:");
    char[] chars443 = {'a', 'a', 'b', 'b', 'c', 'c', 'c'};
    System.out.println(task_443(chars443));

    // 9. Учитывая целое число x, верните true if x палиндром, и false иначе.
    System.out.println("Задача №9:");
    System.out.println(task_9(1001));

    // 13. От римского к целому числу
    System.out.println("Задача №13:");
    System.out.println(task_13("MCMXCIV"));
  }
  // Задача №268
  // Учитывая массив nums, содержащий n различные числа в диапазоне [0, n], верните единственное число в диапазоне,
  // которое отсутствует в массиве.
  private static int task_268(int[] nums) {
    // 9,6,4,2,3,5,7,0,1 - на самом деле должен идти 1, 2, 3, 4, 5, 6, 7, 8, 9
    Arrays.sort(nums);                         // Сортируем массив - 0, 1, 2, 3, 4, 5, 6, 7, 9
    for (int i = 0; i < nums.length; i++) {
      if (i != nums[i])                          // Проверяем если позиции нет в массиве, то возвращаем позицию - 8
        return i;
    }
    return nums.length;                        // Если все хорошо, то не хватает последнего символа
  }
  // 443. Сжатие строк
  /* Учитывая массив символов chars, сжимаем его, используя следующий алгоритм: Начните с пустой строки s.
  Для каждой группы последовательных повторяющихся символов в chars: Если длина группы равна 1, добавьте символ к s.
  В противном случае добавьте символ, за которым следует длина группы. Сжатая строка s не должна возвращаться отдельно,
  а храниться во входном массиве символов chars. Обратите внимание, что длина группы, равная 10 или превышающая ее,
  будет разбита на несколько символов в формате chars. После завершения изменения входного массива верните новую длину
  массива. Вы должны написать алгоритм, который использует только постоянное дополнительное пространство.
  Пример 1:
  Ввод: chars = ["a","a","b","b","c","c","c"]
  Вывод: возвращает 6, и первые 6 символов входного массива должны быть: ["a","2","b","2","c","3"]
  Объяснение: Это группы "aa", "bb" и "ccc". Это сжимается до «a2b2c3».
  Пример 2:
  Ввод: chars = ["a"]
  Выход: Возвращается 1, первый символ входного массива должен быть: ["a"]
  Объяснение: Единственная группа — это «a», которая остается несжатой, поскольку представляет собой один символ.
  Пример 3:
  Ввод: символы = ["a","b","b","b","b","b","b","b","b","b","b"," b","b"]
  Выход: вернуть 4, и первые 4 символа входного массива должны быть: ["a","b","1","2"].
  Пояснение: Это группы «a» и «bbbbbbbbbbbb». Это сжимается до «ab12».
  */
  public static int task_443(char[] chars) {
    int i = 0, res = 0;
    while (i < chars.length) {
      int groupLength = 1;
      while (i + groupLength < chars.length && chars[i + groupLength] == chars[i]) {
        groupLength++;
      }
      chars[res++] = chars[i];
      if (groupLength > 1) {
        for (char c : Integer.toString(groupLength).toCharArray()) {
          chars[res++] = c;
        }
      }
      i += groupLength;
    }
    return res;
  }

  // 9. Учитывая целое число x, верните true if x палиндром, и false иначе.
  /*
  Пример 1:
  Входные данные: x = 121
  Выходные данные: true
  Объяснение: 121 читается как 121 слева направо и справа налево.
  Пример 2:
  Ввод: x = -121
  Вывод: ложь
  Объяснение: Слева направо читается -121. Справа налево становится 121-. Следовательно, это не палиндром.
  Пример 3:
  Ввод: x = 10
  Вывод: ложь
  Объяснение: Считывает 01 справа налево. Следовательно, это не палиндром.
  */
  public static boolean task_9(int x) {
    int y = x; //5345
    int z = y % 10;
    while (y / 10 > 0) {
      y = y / 10;
      z = z * 10 + y % 10;
    }
    if (x == z && x >= 0) return true;
    else return false;
  }
  // 13. От римского к целому числу
  /*
  Римские цифры представлены семью различными символами  : I, V, X, L, C, D и M
  Значение символа
  Symbol      Value
   I            1
   V            5
   X            10
   L            50
   C            100
   D            500
   M            1000
   Например, 2 пишется как II римская цифра, просто складывая две единицы.
   12 пишется как XII, что просто X + II. Число 27 записывается как XXVII, то есть XX + V + II.
   Римские цифры обычно пишутся от большей к меньшей слева направо. Однако цифра «четыре» не является цифрой «четыре»
   IIII. Вместо этого число четыре записывается как IV. Поскольку единица стоит перед пятеркой, мы вычитаем ее, получая
   четыре. Тот же принцип применим и к числу девять, которое записывается как IX.
   Есть шесть случаев, когда используется вычитание:
    I можно поставить перед V(5) и X(10), чтобы получилось 4 и 9.
    X можно поставить перед L(50) и C(100), чтобы получилось 40 и 90.
    C можно поставить перед D(500) и M(1000), чтобы получить 400 и 900.
    Дана римская цифра, преобразуйте ее в целое число.
    Пример 1:
    Ввод: s = «III»
    Выход: 3
    Объяснение: III = 3.
    Пример 2:
    Ввод: s = «LVIII»
    Выход: 58
    Объяснение: L = 50, V = 5, III = 3.
    Пример 3:
    Ввод: s = "MCMXCIV"
    Вывод: 1994
    Объяснение: M = 1000, CM = 900, XC = 90 и IV = 4.
   */
  public static int task_13(String s) {
    int ans = 0, num = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
      switch (s.charAt(i)) {
        case 'I':
          num = 1;
          break;
        case 'V':
          num = 5;
          break;
        case 'X':
          num = 10;
          break;
        case 'L':
          num = 50;
          break;
        case 'C':
          num = 100;
          break;
        case 'D':
          num = 500;
          break;
        case 'M':
          num = 1000;
          break;
      }
      // Если будет комбинация IV, то num=1, а ans=5  и тогда 4*1<5, тогда нам надо отнять 1 от 5
      if (4 * num < ans) ans -= num;
      else ans += num;
    }
    return ans;
  }
}
